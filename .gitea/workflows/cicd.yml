name: CI/CD ChronoTrak

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-and-push:
    runs-on: docker
    steps:
      - name: Configuration du runner
        run: |
          apk add --no-cache \
          docker \
          docker-cli-buildx \
          git \
          curl \
          bash \
          nodejs \
          npm

      - name: Checkout du code avec actions/checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # Calcul du hash des fichiers de dépendances pour le cache
      - name: Calcul du hash des fichiers de build
        id: cache-hash
        run: |
          # Calculer le hash des fichiers qui affectent le build Docker
          if command -v sha256sum >/dev/null 2>&1; then
            DOCKERFILE_HASH=$(sha256sum Dockerfile | cut -d' ' -f1)
            PYPROJECT_HASH=$(sha256sum pyproject.toml | cut -d' ' -f1)
          elif command -v sha256 >/dev/null 2>&1; then
            DOCKERFILE_HASH=$(sha256 -q Dockerfile)
            PYPROJECT_HASH=$(sha256 -q pyproject.toml)
          else
            # Fallback: utiliser md5sum si disponible
            DOCKERFILE_HASH=$(md5sum Dockerfile | cut -d' ' -f1)
            PYPROJECT_HASH=$(md5sum pyproject.toml | cut -d' ' -f1)
          fi
          
          # Combiner les hashs pour créer une clé unique
          CACHE_KEY_HASH=$(echo "${DOCKERFILE_HASH}-${PYPROJECT_HASH}" | sha256sum | cut -d' ' -f1 || echo "${DOCKERFILE_HASH}-${PYPROJECT_HASH}")
          
          echo "DOCKERFILE_HASH=${DOCKERFILE_HASH}" >> $GITEA_ENV
          echo "PYPROJECT_HASH=${PYPROJECT_HASH}" >> $GITEA_ENV
          echo "CACHE_KEY_HASH=${CACHE_KEY_HASH}" >> $GITEA_ENV
          echo "Hash Dockerfile: ${DOCKERFILE_HASH:0:12}..."
          echo "Hash pyproject.toml: ${PYPROJECT_HASH:0:12}..."
          echo "Clé de cache: ${CACHE_KEY_HASH:0:16}..."

      # Configuration du cache Docker
      - name: Configuration du cache Docker
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ env.CACHE_KEY_HASH }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      # Détecter la version
      - name: Détecter la version
        id: version
        run: |
          VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$VERSION" ]; then
            BRANCH=$(git branch --show-current)
            if [[ "$BRANCH" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              VERSION="$BRANCH"
            fi
          fi
          if [ -z "$VERSION" ]; then
            VERSION="v1.0.0-dev"
          fi
          echo "VERSION=$VERSION" >> $GITEA_ENV
          echo "Version détectée: $VERSION"

      # Authentification au registre
      - name: Login au registre Docker
        run: |
          echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login forge.apacher.eu -u "${{ secrets.REGISTRY_USERNAME }}" --password-stdin

      # Construction et push de l'image - VERSION OPTIMISÉE
      - name: Build et push de l'image Docker
        run: |
          set -e
          
          # Nettoyage préventif des anciens conteneurs BuildKit
          echo "Nettoyage préventif des conteneurs BuildKit..."
          docker container ls -q --filter "name=buildx_buildkit" | xargs -r docker container stop || true
          docker container ls -aq --filter "name=buildx_buildkit" | xargs -r docker container rm || true
          
          # Gestion intelligente du builder
          BUILDER_NAME="chronotrak-builder"
          
          if docker buildx ls | grep -q "$BUILDER_NAME"; then
            echo "Utilisation du builder existant: $BUILDER_NAME"
            docker buildx use $BUILDER_NAME
          else
            echo "Création d'un nouveau builder: $BUILDER_NAME"
            docker buildx create --name $BUILDER_NAME --use
          fi
          
          # Build avec gestion d'erreurs et cache optimisé
          echo "Démarrage du build de l'image..."
          docker buildx build --provenance=false --push \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-from=type=registry,ref=forge.apacher.eu/aurelien-dazy/chronotrak:buildcache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            --cache-to=type=registry,ref=forge.apacher.eu/aurelien-dazy/chronotrak:buildcache,mode=max \
            --build-arg VERSION="${{ env.VERSION }}" \
            --tag forge.apacher.eu/aurelien-dazy/chronotrak:latest \
            --tag forge.apacher.eu/aurelien-dazy/chronotrak:${{ env.VERSION }} \
            --progress=plain \
            .
          
          echo "Build terminé avec succès"

      # Gestion du cache et nettoyage SÉCURISÉ
      - name: Gestion du cache et nettoyage sécurisé
        if: always()
        run: |
          # Gestion du cache
          if [ -d "/tmp/.buildx-cache-new" ]; then
            rm -rf /tmp/.buildx-cache
            mv /tmp/.buildx-cache-new /tmp/.buildx-cache
            echo "Cache mis à jour"
          fi
          
          # Nettoyage CIBLÉ des conteneurs BuildKit seulement
          echo "Nettoyage ciblé des conteneurs BuildKit..."
          BUILDKIT_CONTAINERS=$(docker container ls -aq --filter "name=buildx_buildkit" --filter "label=org.mobyproject.buildkit.worker.executor=oci" 2>/dev/null || echo "")
          
          if [ ! -z "$BUILDKIT_CONTAINERS" ]; then
            echo "Suppression des conteneurs BuildKit: $BUILDKIT_CONTAINERS"
            docker container rm -f $BUILDKIT_CONTAINERS 2>/dev/null || true
          else
            echo "Aucun conteneur BuildKit à supprimer"
          fi
          
          # Nettoyage du cache BuildKit uniquement (pas docker system)
          echo "Nettoyage du cache BuildKit..."
          docker buildx prune -f --reserved-space=1GB 2>/dev/null || true
          
          # Nettoyage des images build temporaires sans tag (plus sûr)
          echo "Nettoyage des images temporaires..."
          docker image prune -f --filter "dangling=true" 2>/dev/null || true
          
          # Nettoyage des volumes BuildKit uniquement (SÉCURISÉ)
          echo "Nettoyage des volumes BuildKit..."
          docker volume ls --filter "name=buildx_buildkit_" --format "{{.Name}}" | xargs -r docker volume rm 2>/dev/null || true
          
          # Affichage des statistiques pour monitoring
          echo "=== État final des builders ==="
          docker buildx ls
          echo "=== Conteneurs BuildKit restants ==="
          docker container ls --filter "name=buildx_buildkit" --format "table {{.Names}}\t{{.Status}}\t{{.CreatedAt}}" || true
          echo "=== Utilisation disque Docker ==="
          docker system df || true

      # Analyse de sécurité avec Trivy (uniquement sur main/master)
      - name: Installation et exécution de Trivy
        if: gitea.ref == 'refs/heads/main' || gitea.ref == 'refs/heads/master'
        run: |
          apk add --no-cache curl
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
          # Ignorer les vulnérabilités déjà corrigées (status: fixed)
          trivy image forge.apacher.eu/aurelien-dazy/chronotrak:latest \
            --severity HIGH,CRITICAL \
            --ignore-status fixed \
            --exit-code 1

  deploy:
    needs: build-and-push
    runs-on: docker
    container:
      image: docker:latest
    steps:
      # Installation des dépendances SSH
      - name: Installation des dépendances SSH
        run: |
          apk add --no-cache openssh-client bash file
          mkdir -p ~/.ssh
          echo "StrictHostKeyChecking=no" > ~/.ssh/config
          chmod 600 ~/.ssh/config

      # Configuration de la clé SSH
      - name: Configuration de la clé SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PROD_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

      # Test de connexion SSH
      - name: Test de connexion SSH
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_ed25519 -p ${{ secrets.PROD_SSH_PORT }} ${{ secrets.PROD_SSH_USERNAME }}@${{ secrets.PROD_SSH_HOST }} "echo 'Connexion SSH réussie'"

      # Sauvegarde de la base de données (uniquement sur main/master)
      - name: Sauvegarde de la base de données
        if: gitea.ref == 'refs/heads/main' || gitea.ref == 'refs/heads/master'
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_ed25519 -p ${{ secrets.PROD_SSH_PORT }} ${{ secrets.PROD_SSH_USERNAME }}@${{ secrets.PROD_SSH_HOST }} "
            set -ex
            echo 'Création du répertoire de sauvegarde'
            mkdir -p ${{ secrets.PROJECT_DIRECTORY }}/backups
            
            echo 'Sauvegarde de la base de données'
            cd ${{ secrets.PROJECT_DIRECTORY }}
            
            BACKUP_DATE=\$(date +'%Y%m%d_%H%M%S')
            
            docker run --rm -v docker-chronotrak_chronotrak_data:/app/instance -v ${{ secrets.PROJECT_DIRECTORY }}/backups:/backup alpine sh -c \"
              if [ -f /app/instance/chronotrak.db ]; then
                cp /app/instance/chronotrak.db /backup/chronotrak_\${BACKUP_DATE}.db
                echo 'Sauvegarde effectuée avec succès'
              else
                echo 'Base de données non trouvée dans le volume'
                touch /backup/chronotrak_\${BACKUP_DATE}_empty.txt
              fi
            \"
            
            cd ${{ secrets.PROJECT_DIRECTORY }}/backups
            ls -t chronotrak_*.db | tail -n +11 | xargs -r rm
            
            echo 'Sauvegarde terminée'
          "
      
      # Déploiement sur le serveur de production
      - name: Déploiement sur le serveur de production
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_ed25519 -p ${{ secrets.PROD_SSH_PORT }} ${{ secrets.PROD_SSH_USERNAME }}@${{ secrets.PROD_SSH_HOST }} "
            set -ex
            echo 'Début du déploiement'
            cd ${{ secrets.PROJECT_DIRECTORY }}
            
            # Login au registre
            docker login forge.apacher.eu -u ${{ secrets.REGISTRY_USERNAME }} -p ${{ secrets.REGISTRY_PASSWORD }}
            
            # Pull et déploiement
            ENVIRONMENT=production docker compose pull
            ENVIRONMENT=production docker compose up -d
            
            # Nettoyage post-déploiement
            docker system prune -f
            # Nettoyage des volumes BuildKit uniquement sur le serveur de production
            docker volume ls --filter "name=buildx_buildkit_" --format "{{.Name}}" | xargs -r docker volume rm 2>/dev/null || true
            docker logout forge.apacher.eu
            
            echo 'Déploiement terminé avec succès'
          "